<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë…ë„ ìˆ˜í˜¸ëŒ€: ì—­ì‚¬ ì™œê³¡ì„ ë§‰ì•„ë¼!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Jua&family=Noto+Sans+KR:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans KR', sans-serif;
            overflow: hidden;
            touch-action: none;
            background-color: #1a202c;
        }
        
        .font-jua {
            font-family: 'Jua', sans-serif;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(to bottom, #87CEEB 0%, #1E90FF 50%, #000080 100%);
            overflow: hidden;
        }

        .modal {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        /* Wave Effect for Sea */
        .wave {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 200%;
            height: 100px;
            background: url('data:image/svg+xml;utf8,<svg viewBox="0 0 1200 120" xmlns="http://www.w3.org/2000/svg"><path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.2C989.49,25,1113-14.29,1200,52.47V0Z" opacity=".25" fill="%23FFFFFF"/></svg>') repeat-x;
            background-size: 50% 100%;
            animation: wave 10s linear infinite;
            pointer-events: none;
            z-index: 1;
        }
        .wave:nth-of-type(2) {
            bottom: 10px;
            opacity: 0.5;
            animation: wave 7s linear infinite reverse;
        }

        @keyframes wave {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        .quiz-btn {
            transition: all 0.2s;
        }
        .quiz-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- Background Waves -->
    <div class="wave"></div>
    <div class="wave"></div>

    <!-- Canvas for Game Rendering -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay: Score & Health -->
    <div class="absolute top-4 left-4 flex flex-col gap-2 z-10 text-white font-jua text-shadow-md">
        <div class="text-2xl">ì ìˆ˜: <span id="scoreDisplay">0</span></div>
        <div class="text-xl text-red-300">ë°©ì–´ë§‰: <span id="healthDisplay">100</span>%</div>
        <div class="text-sm text-gray-200">ë ˆë²¨: <span id="levelDisplay">1</span></div>
    </div>

    <!-- Home Button (Modified) -->
    <a href="index.html" class="absolute top-4 right-4 z-50 px-6 py-2 bg-blue-600 hover:bg-blue-500 border-2 border-blue-300 text-white font-jua rounded-full shadow-lg transition-transform hover:scale-105 active:scale-95 text-lg tracking-wide flex items-center gap-2 decoration-none">
        <span>ğŸ </span>
        <span>í™ˆìœ¼ë¡œ</span>
    </a>

    <!-- Start Screen -->
    <div id="startScreen" class="absolute inset-0 flex items-center justify-center z-50 bg-black/60">
        <div class="modal p-8 text-center max-w-md w-full mx-4 border-4 border-blue-500">
            <h1 class="text-4xl font-jua text-blue-600 mb-2">ë…ë„ ìˆ˜í˜¸ëŒ€</h1>
            <h2 class="text-xl font-bold text-gray-700 mb-6">ì—­ì‚¬ ì™œê³¡ì„ ë§‰ì•„ë¼!</h2>
            <div class="mb-6 text-left text-gray-600 space-y-2 text-sm">
                <p>ğŸ‘» <b>ì™œê³¡ ìœ ë ¹</b>ë“¤ì´ ë…ë„ì— ë‹¤ê°€ì˜µë‹ˆë‹¤.</p>
                <p>ğŸ‘† ìœ ë ¹ì„ <b>í´ë¦­(í„°ì¹˜)</b>í•˜ì—¬ ë¬¼ë¦¬ì¹˜ì„¸ìš”!</p>
                <p>ğŸ§  ê°€ë” ë‚˜íƒ€ë‚˜ëŠ” <b>í€´ì¦ˆ</b>ë¥¼ ë§íˆë©´ ë°©ì–´ë§‰ì´ íšŒë³µë©ë‹ˆë‹¤.</p>
                <p>ğŸ“š <b>ìë£Œ ê¸°ë°˜:</b> ì œê³µí•´ì£¼ì‹  ë…ë„ í•™ìŠµ ìë£Œë¥¼ ë°”íƒ•ìœ¼ë¡œ í•©ë‹ˆë‹¤.</p>
            </div>
            <button onclick="startGame()" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg text-xl shadow-lg transform transition hover:-translate-y-1">
                ìˆ˜í˜¸ ì‹œì‘í•˜ê¸°!
            </button>
        </div>
    </div>

    <!-- Quiz Modal -->
    <div id="quizModal" class="hidden absolute inset-0 flex items-center justify-center z-40 bg-black/70">
        <div class="modal p-6 max-w-lg w-full mx-4 border-4 border-yellow-400">
            <div class="flex justify-between items-center mb-4">
                <span class="bg-yellow-100 text-yellow-800 text-xs font-semibold px-2.5 py-0.5 rounded">ë…ë„ ì§€ì‹ ì²´í¬</span>
                <span id="quizTimer" class="text-red-500 font-bold">15s</span>
            </div>
            <h3 id="quizQuestion" class="text-xl font-bold text-gray-800 mb-6 leading-relaxed">
                ë¬¸ì œ ë‚´ìš©ì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
            </h3>
            <div id="quizOptions" class="grid gap-3">
                <!-- Options will be injected here -->
            </div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="hidden absolute inset-0 flex items-center justify-center z-50 bg-black/80">
        <div class="modal p-8 text-center max-w-md w-full mx-4 border-4 border-red-500">
            <h2 class="text-3xl font-jua text-red-600 mb-4">ë°©ì–´ ì‹¤íŒ¨...</h2>
            <p class="text-gray-700 mb-2">ìµœì¢… ì ìˆ˜</p>
            <p id="finalScore" class="text-4xl font-bold text-gray-900 mb-6">0</p>
            <p class="text-sm text-gray-500 mb-6">ë…ë„ì— ëŒ€í•œ ì •í™•í•œ ì§€ì‹ì´<br>ìš°ë¦¬ ë•…ì„ ì§€í‚¤ëŠ” í˜ì…ë‹ˆë‹¤!</p>
            <button onclick="resetGame()" class="w-full bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg text-xl shadow-lg">
                ë‹¤ì‹œ ë„ì „í•˜ê¸°
            </button>
        </div>
    </div>
</div>

<script>
    /**
     * Game Data derived from uploaded PDFs
     */
    const QUIZ_DATA = [
        {
            q: "ë…ë„ì˜ í–‰ì • êµ¬ì—­ìƒ ì£¼ì†ŒëŠ” ê²½ìƒë¶ë„ ìš¸ë¦‰êµ° ìš¸ë¦‰ì OOO ì´ë‹¤. ë¹ˆì¹¸ì— ë“¤ì–´ê°ˆ ë§ì€?",
            a: ["ë…ë„ë¦¬", "ìš°ì‚°ë¦¬", "ì£½ë„ë¦¬", "ì„ë„ë¦¬"],
            correct: 0,
            desc: "ë…ë„ì˜ ì£¼ì†ŒëŠ” ê²½ìƒë¶ë„ ìš¸ë¦‰êµ° ìš¸ë¦‰ì ë…ë„ë¦¬ 1~96ë²ˆì§€ì…ë‹ˆë‹¤."
        },
        {
            q: "1900ë…„ ëŒ€í•œì œêµ­ ì¹™ë ¹ ì œ41í˜¸ì—ì„œ ë…ë„ë¥¼ ì§€ì¹­í•œ ëª…ì¹­ì€?",
            a: ["ì„ë„(çŸ³å³¶)", "ì£½ë„(ç«¹å³¶)", "ì†¡ë„(æ¾å³¶)", "ìš°ì‚°ë„"],
            correct: 0,
            desc: "ëŒ€í•œì œêµ­ì€ ì¹™ë ¹ ì œ41í˜¸ë¥¼ í†µí•´ ìš¸ë¦‰ë„ë¥¼ ìš¸ë„êµ°ìœ¼ë¡œ ìŠ¹ê²©ì‹œí‚¤ê³ , ê´€í•  êµ¬ì—­ìœ¼ë¡œ ì„ë„(ë…ë„)ë¥¼ ëª…ì‹œí–ˆìŠµë‹ˆë‹¤."
        },
        {
            q: "ë…ë„ ì£¼ë³€ í•´ì—­ì— ë§¤ì¥ëœ 'ë¶ˆíƒ€ëŠ” ì–¼ìŒ'ì´ë¼ ë¶ˆë¦¬ëŠ” ë¯¸ë˜ ì—ë„ˆì§€ ìì›ì€?",
            a: ["ê°€ìŠ¤ í•˜ì´ë“œë ˆì´íŠ¸", "ì²œì—°ê°€ìŠ¤", "ì„ìœ ", "ë§ê°„ë‹¨ê´´"],
            correct: 0,
            desc: "ë…ë„ ì¸ê·¼ì—ëŠ” ë©”íƒ„ì´ ì£¼ì„±ë¶„ì¸ ê°€ìŠ¤ í•˜ì´ë“œë ˆì´íŠ¸ê°€ í’ë¶€í•˜ê²Œ ë§¤ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤."
        },
        {
            q: "ì¡°ì„  ìˆ™ì¢… ë•Œ(1696ë…„) ì¼ë³¸ìœ¼ë¡œ ê±´ë„ˆê°€ ë…ë„ê°€ ì¡°ì„  ë•…ì„ì„ í™•ì¸ë°›ê³  ëŒì•„ì˜¨ ì¸ë¬¼ì€?",
            a: ["ì•ˆìš©ë³µ", "ì´ì‚¬ë¶€", "ì´ìˆœì‹ ", "ì‹¬í¥íƒ"],
            correct: 0,
            desc: "ì•ˆìš©ë³µì€ ë‘ ì°¨ë¡€ ì¼ë³¸ìœ¼ë¡œ ê±´ë„ˆê°€ ìš¸ë¦‰ë„ì™€ ë…ë„ê°€ ì¡°ì„ ì˜ ì˜í† ì„ì„ ê°•ë ¥íˆ ì£¼ì¥í•˜ê³  ì¼ë³¸ ë§‰ë¶€ì˜ ì¸ì •ì„ ë°›ì•„ëƒˆìŠµë‹ˆë‹¤."
        },
        {
            q: "ë…ë„ëŠ” í¬ê²Œ ë‘ ê°œì˜ ì„¬ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤. ë‘ ì„¬ì˜ ì´ë¦„ì€?",
            a: ["ë™ë„ì™€ ì„œë„", "ë‚¨ë„ì™€ ë¶ë„", "ìš°ì‚°ë„ì™€ ì£½ë„", "ëŒ€ë„ì™€ ì†Œë„"],
            correct: 0,
            desc: "ë…ë„ëŠ” ë™ë„ì™€ ì„œë„ 2ê°œì˜ í° ì„¬ê³¼ 89ê°œì˜ ë¶€ì† ë„ì„œë¡œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤."
        },
        {
            q: "ì¼ë³¸ ì‹œë§ˆë„¤í˜„ì´ ë¶ˆë²•ì ìœ¼ë¡œ ë‹¤ì¼€ì‹œë§ˆì˜ ë‚ ë¡œ ì •í•œ ë‚ ì§œëŠ”?",
            a: ["2ì›” 22ì¼", "10ì›” 25ì¼", "8ì›” 15ì¼", "3ì›” 1ì¼"],
            correct: 0,
            desc: "ì¼ë³¸ì€ 1905ë…„ ì‹œë§ˆë„¤í˜„ ê³ ì‹œ ì œ40í˜¸ë¥¼ ê·¼ê±°ë¡œ 2ì›” 22ì¼ì„ ë‹¤ì¼€ì‹œë§ˆì˜ ë‚ ë¡œ ì£¼ì¥í•˜ì§€ë§Œ, ì´ëŠ” ë¶ˆë²•ì ì¸ í¸ì…ì…ë‹ˆë‹¤. (ë…ë„ì˜ ë‚ ì€ 10ì›” 25ì¼)"
        },
        {
            q: "í•´ìˆ˜ë©´ ì•„ë˜ì—ì„œ í˜•ì„±ëœ í™”ì‚°ì²´ì¸ ë…ë„ì™€ ìš¸ë¦‰ë„ ê°™ì€ ì§€í˜•ì„ ë¬´ì—‡ì´ë¼ í•˜ëŠ”ê°€?",
            a: ["í•´ì‚° (Seamount)", "ëŒ€ë¥™ë¶•", "í•´êµ¬", "ì‚°í˜¸ì´ˆ"],
            correct: 0,
            desc: "ë…ë„ì™€ ìš¸ë¦‰ë„ëŠ” í•´ì € ì•½ 2,000mì—ì„œ ì†Ÿì•„ì˜¤ë¥¸ ê±°ëŒ€í•œ í•´ì‚°(Seamount)ì˜ ìœ—ë¶€ë¶„ì…ë‹ˆë‹¤."
        },
        {
            q: "1785ë…„ ì¼ë³¸ ì‹¤í•™ì í•˜ì•¼ì‹œ ì‹œí—¤ì´ê°€ ì œì‘í•œ ì§€ë„ë¡œ, ë…ë„ë¥¼ ì¡°ì„ ì˜ ìƒ‰(í™©ìƒ‰)ìœ¼ë¡œ ì¹ í•œ ì§€ë„ëŠ”?",
            a: ["ì‚¼êµ­ì ‘ì–‘ì§€ë„", "ëŒ€ë™ì—¬ì§€ë„", "í˜¼ì¼ê°•ë¦¬ì—­ëŒ€êµ­ë„ì§€ë„", "ê°œì •ì¼ë³¸ì—¬ì§€ë¡œì •ì „ë„"],
            correct: 0,
            desc: "ì‚¼êµ­ì ‘ì–‘ì§€ë„ëŠ” ìš¸ë¦‰ë„ì™€ ë…ë„ë¥¼ ì¡°ì„  ë³¸í† ì™€ ê°™ì€ í™©ìƒ‰ìœ¼ë¡œ ì±„ìƒ‰í•˜ì—¬ ì¡°ì„ ì˜ ì˜í† ì„ì„ ëª…í™•íˆ í–ˆìŠµë‹ˆë‹¤."
        }
    ];

    /* --- Game Constants & State --- */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameState = 'start'; // start, playing, quiz, gameover
    let score = 0;
    let health = 100;
    let level = 1;
    let lastTime = 0;
    let spawnTimer = 0;
    let spawnInterval = 2000;
    let enemies = [];
    let particles = [];
    let quizIntervalCounter = 0;
    let quizThreshold = 1000; // Show quiz every 1000 points
    let currentQuizIndex = -1;
    let quizTimerInterval;

    // Dokdo Asset Representation
    const DOKDO = {
        x: 0, y: 0, 
        radius: 60,
        color: '#4ADE80' // Green
    };

    /* --- Resize Handling --- */
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        DOKDO.x = canvas.width / 2;
        DOKDO.y = canvas.height / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    /* --- Game Logic --- */

    function startGame() {
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        resetGameState();
        gameState = 'playing';
        requestAnimationFrame(gameLoop);
    }

    function resetGameState() {
        score = 0;
        health = 100;
        level = 1;
        enemies = [];
        particles = [];
        quizIntervalCounter = 0;
        spawnInterval = 2000;
        updateUI();
    }

    function resetGame() {
        startGame();
    }

    function spawnEnemy() {
        // Spawn from edges
        const side = Math.floor(Math.random() * 4); // 0:top, 1:right, 2:bottom, 3:left
        let x, y;
        const buffer = 50;
        
        switch(side) {
            case 0: x = Math.random() * canvas.width; y = -buffer; break;
            case 1: x = canvas.width + buffer; y = Math.random() * canvas.height; break;
            case 2: x = Math.random() * canvas.width; y = canvas.height + buffer; break;
            case 3: x = -buffer; y = Math.random() * canvas.height; break;
        }

        const angle = Math.atan2(DOKDO.y - y, DOKDO.x - x);
        const speed = 1 + (level * 0.2) + (Math.random() * 1);
        
        // Enemy types
        const type = Math.random() > 0.8 ? 'FAST' : 'NORMAL';

        enemies.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: type === 'FAST' ? 25 : 35,
            color: type === 'FAST' ? '#F87171' : '#A78BFA', // Red or Purple
            text: type === 'FAST' ? 'ì™œê³¡' : 'ë§ì–¸',
            hp: type === 'FAST' ? 1 : 2,
            type: type
        });
    }

    function createParticles(x, y, color) {
        for(let i=0; i<8; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                life: 1.0,
                color: color
            });
        }
    }

    function update(dt) {
        if (gameState !== 'playing') return;

        // Spawning
        spawnTimer += dt;
        if (spawnTimer > spawnInterval) {
            spawnEnemy();
            spawnTimer = 0;
            // Increase difficulty
            if (spawnInterval > 500) spawnInterval -= 10;
        }

        // Update Enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            e.x += e.vx;
            e.y += e.vy;

            // Collision with Dokdo
            const dist = Math.hypot(e.x - DOKDO.x, e.y - DOKDO.y);
            if (dist < DOKDO.radius + e.radius) {
                health -= 10;
                createParticles(e.x, e.y, '#EF4444');
                enemies.splice(i, 1);
                updateUI();
                
                // Shake effect
                canvas.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
                setTimeout(() => canvas.style.transform = 'none', 50);

                if (health <= 0) {
                    gameState = 'gameover';
                    document.getElementById('finalScore').innerText = score;
                    document.getElementById('gameOverScreen').classList.remove('hidden');
                }
            }
        }

        // Update Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Dokdo (Center)
        ctx.beginPath();
        ctx.arc(DOKDO.x - 20, DOKDO.y, 40, 0, Math.PI * 2); // West Islet
        ctx.fillStyle = '#10B981';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(DOKDO.x + 20, DOKDO.y - 10, 35, 0, Math.PI * 2); // East Islet
        ctx.fillStyle = '#059669';
        ctx.fill();
        
        // Korean Flag on Dokdo
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('ğŸ‡°ğŸ‡·', DOKDO.x, DOKDO.y - 40);

        // Shield Effect
        if (health > 0) {
            ctx.beginPath();
            ctx.arc(DOKDO.x, DOKDO.y, DOKDO.radius + 10, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(100, 200, 255, ${health/200})`;
            ctx.lineWidth = 5;
            ctx.stroke();
        }

        // Draw Enemies
        enemies.forEach(e => {
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
            ctx.fillStyle = e.color;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Ghost Face
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('ğŸ‘»', e.x, e.y - 5);
            ctx.font = '12px Noto Sans KR';
            ctx.fillText(e.text, e.x, e.y + 15);
        });

        // Draw Particles
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
            ctx.globalAlpha = 1.0;
        });
    }

    function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = timestamp - lastTime;
        lastTime = timestamp;

        update(dt);
        draw();

        if (gameState === 'playing') {
            requestAnimationFrame(gameLoop);
        }
    }

    /* --- Input Handling --- */
    window.addEventListener('pointerdown', (e) => {
        if (gameState !== 'playing') return;

        const rect = canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;

        for (let i = enemies.length - 1; i >= 0; i--) {
            const ent = enemies[i];
            const dist = Math.hypot(clickX - ent.x, clickY - ent.y);

            // Hit detection (Generous box)
            if (dist < ent.radius + 20) {
                ent.hp--;
                createParticles(ent.x, ent.y, '#FFFF00');
                
                if (ent.hp <= 0) {
                    enemies.splice(i, 1);
                    addScore(100);
                } else {
                    // Knockback
                    ent.x -= ent.vx * 10;
                    ent.y -= ent.vy * 10;
                }
                break; // Click one at a time
            }
        }
    });

    function addScore(points) {
        score += points;
        quizIntervalCounter += points;
        
        // Level Up logic
        if (score % 2000 === 0) {
            level++;
        }

        // Trigger Quiz
        if (quizIntervalCounter >= quizThreshold) {
            triggerQuiz();
            quizIntervalCounter = 0;
        }
        updateUI();
    }

    function updateUI() {
        document.getElementById('scoreDisplay').innerText = score;
        document.getElementById('healthDisplay').innerText = health;
        document.getElementById('levelDisplay').innerText = level;
    }

    /* --- Quiz System --- */
    function triggerQuiz() {
        gameState = 'quiz';
        const modal = document.getElementById('quizModal');
        const qContainer = document.getElementById('quizQuestion');
        const oContainer = document.getElementById('quizOptions');
        const timerDisplay = document.getElementById('quizTimer');

        // Pick random question
        const qIndex = Math.floor(Math.random() * QUIZ_DATA.length);
        const qData = QUIZ_DATA[qIndex];
        currentQuizIndex = qIndex;

        qContainer.innerText = `Q. ${qData.q}`;
        oContainer.innerHTML = '';

        qData.a.forEach((opt, idx) => {
            const btn = document.createElement('button');
            btn.className = 'quiz-btn w-full text-left bg-gray-100 hover:bg-blue-100 border border-gray-300 rounded-lg p-3 text-gray-800 font-bold';
            btn.innerText = `(${idx+1}) ${opt}`;
            btn.onclick = () => checkAnswer(idx);
            oContainer.appendChild(btn);
        });

        modal.classList.remove('hidden');

        // Timer logic
        let timeLeft = 15;
        timerDisplay.innerText = timeLeft + 's';
        clearInterval(quizTimerInterval);
        quizTimerInterval = setInterval(() => {
            timeLeft--;
            timerDisplay.innerText = timeLeft + 's';
            if (timeLeft <= 0) {
                clearInterval(quizTimerInterval);
                closeQuiz(false);
            }
        }, 1000);
    }

    function checkAnswer(selectedIndex) {
        clearInterval(quizTimerInterval);
        const isCorrect = selectedIndex === QUIZ_DATA[currentQuizIndex].correct;
        const btns = document.querySelectorAll('.quiz-btn');
        
        btns[selectedIndex].classList.remove('bg-gray-100', 'hover:bg-blue-100');
        
        if (isCorrect) {
            btns[selectedIndex].classList.add('bg-green-500', 'text-white');
            setTimeout(() => closeQuiz(true), 1000);
        } else {
            btns[selectedIndex].classList.add('bg-red-500', 'text-white');
            // Show correct answer
            btns[QUIZ_DATA[currentQuizIndex].correct].classList.add('bg-green-500', 'text-white', 'ring-2', 'ring-green-700');
            setTimeout(() => closeQuiz(false), 2000); // Wait longer to see answer
        }
    }

    function closeQuiz(success) {
        document.getElementById('quizModal').classList.add('hidden');
        
        if (success) {
            health = Math.min(100, health + 30); // Heal
            score += 500; // Bonus score
            // Clear all enemies on screen as a "Bomb" effect
            enemies.forEach(e => createParticles(e.x, e.y, '#FFFFFF'));
            enemies = [];
            
            // Show success text
            const msg = document.createElement('div');
            msg.innerText = "ì •ë‹µ! ë°©ì–´ë§‰ íšŒë³µ!";
            msg.className = "absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-4xl font-bold text-green-400 font-jua z-50 animate-bounce";
            document.body.appendChild(msg);
            setTimeout(() => msg.remove(), 1500);

        } else {
            // Failure penalty
            createParticles(DOKDO.x, DOKDO.y, '#000000');
        }

        updateUI();
        gameState = 'playing';
        lastTime = performance.now(); // Reset time to prevent huge dt jump
        requestAnimationFrame(gameLoop);
    }

</script>
</body>
</html>
